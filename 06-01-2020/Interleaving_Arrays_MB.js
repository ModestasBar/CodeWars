/*
Create a function, that accepts an arbitrary number of arrays and returns a single array 
generated by alternately appending elements from the passed in arguments. If one of them 
is shorter than the others, the result should be padded with empty elements.
*/

const maxLength = (args) => {
    return Math.max(...[...args].map(x => x.length));
}

const interleave = (...args) => {
    const tempArr = [];

    const maxArr = maxLength(args);

    const valNumb= args.length;

    for(let i = 0; i < maxArr; i++){
        for(let j = 0; j < valNumb; j++) {
            if(typeof(args[j][i]) === 'undefined'){
                tempArr.push(null);
                continue;
            }
            tempArr.push(args[j][i]);
        }
    }
    return tempArr;
}

/*
Alternative:

const interleave = (...a) => {
  let interleaved = []
  const longest = a.reduce((a, b) => (a.length > b.length ? a : b));

  for (let i in longest) {
    a.forEach(word => word[i] === undefined ? interleaved.push(null) : interleaved.push(word[i]));
  }
  return interleaved;
};

function interleave (...args) {
  const n = Math.max(...args.map(arg => arg.length));
  return Array.from({ length: n }).reduce((acc, _, i) => 
    acc.concat(...args.map(arg => i < arg.length ? arg[i] : null)
  ), []);
}

*/